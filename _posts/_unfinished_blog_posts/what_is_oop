Object oriented programming is a popular, if not ubiquitous programming paradigm implemented in many languages.  Yet, it is so often inappropriately used.  What is OOP and why should (or shouldn't) we use it?  In this post, we'll learn how OOP, contrary to the popular methodology, is usually not a paradigm we need to implement for a typical programming problem because it is (usually) already implicitly implemented.

What is an object?  An object is something recognizable from a space or collection.  This doesn't necessarily mean that we can know what the object is or what it does, but that given an object in some space, the object is somehow interacting with this space.  So by identifying a relationship between an object and space, we are implicitly claiming an object has identity.  Furthermore, if an object has identity, then we can deduce that the object must have state because there is some characteristic stored in the object that gives it identity.  In sum, an object has state and is recognizable from some space.

In fact, if an object is identifiable by space, then it interacts with the space it is identified in.  From this fact we can deduce that an object has behaviors.  The object could accept input or produce output.  If an object accepts input, it is callable, and we can deduce that from the point of view of space, the object serves at least one purpose (that is, to accept input).  We can apply the same logic to an object producing output.  If an object outputs something to space, its purpose, from the point of view of space, is to output something.  We have now learned that an object has both state and behavior, and that fom the point of view of space, an object behaves in identifiable ways.

So far, we have deduced that an object has state and behavior from the initial claim that an object is recognized by a space, but why should a programmer care about this deduction?  Rephrasing our deduction:

HERE

 that the object is doing two things.  On one hand, it namespaces a group of behaviors into methods, and on the other, it stores state.  
So why have we gone through the trouble to define what an object is?  As programmers, we use objects to help us write programs.  As humans, we can only conceptualize a few things at a time.  So as human programmers, we write programs that reflect our inherent limitations.  Specifically, each concept we identify should have one simply and clearly defined purpose.  Programming with objects should therefore be no different.  This means that the object should be a simple entity, and it should exist only when we can't express the problem more simply using namespaces and functions.  Moreover, properly designed objects don't read into the environment and can't modify themselves according to some implicit purpose without being explicitly told what to do.

We should only use objects when it is the simplest option.  And that means that we shouldn't we use objects most of the time (unless, of course, the language is strongly object oriented).  When shouldn't we use OOP?  We shouldn't use objects to structure and organize our code.  Modules and functions are simpler, don't need to be instantiated, and serve the same purpose.  Additionally, objects should should not model data when the data can be expressed by a hash, array, set or any other type built into the language.  ORMs and Data Mapper patterns, for instance, are quite common and can be useful, but they are overly complicated.  Generally, ORMs aren't useful except for cases where speedy short-term development is required.  Objects also shouldn't be used to help generate side effects.  The presence of side effects implies that the problem is overcomplicated and can be broken down into simpler ones.  Also, we shouldn't use objects to make our code more flexible.  Object oriented design is a paradigm, and programming according to paradigm means adhering to the constraints defined by that paradigm.  Lastly, by programming, we are asking hardware do something to accomplish some goal.  As a programmer, we program actions, not objects.  Therefore, we should think about what actions we're trying to define, and our final result should only reflect those intentions.

While I rarely find use cases for object oriented design, there are certainly valid uses for it.  If the code base or language conforms to an object oriented design, it generally makes sense to maintain that conformity.  Also, sometimes the problem a programmer is trying to solve is one of defining an object rather than an object's actions.  This may be especially applicable if you are programming to help yourself think through a problem.  Personally, I try to think about the problem space before I code to reinforce good habits, but like free-writing, sometimes the easiest way to start on a problem is by sketching out some object.  Objects can also be useful in cases where the programmer needs to be forcibly limited; OOP is an excellent teaching tool.

